{"version":3,"sources":["PathVisualizer/Info/Info.jsx","PathVisualizer/Tutorial/Tutorial.jsx","PathVisualizer/NavBar/NavBar.jsx","PathVisualizer/Node/Node.jsx","Algorithms/HeapAStar.js","Algorithms/AStar.js","Algorithms/BreadthFirstSearch.js","Algorithms/DepthFirstSearch.js","Algorithms/HeapDijkstra.js","Algorithms/Djikstra.js","Mazes/RecursiveDivision.js","PathVisualizer/PathVisualizer.jsx","App.js","index.js"],"names":["Info","className","ListGroup","horizontal","Item","Tutorial","tutorial","showTutorial","Modal","size","show","onHide","aria-labelledby","Header","closeButton","Title","id","Body","class","Button","variant","Footer","onClick","NavBar","props","useState","mainButton","setMainButton","setTutorial","clearGrid","clearPath","clearWalls","clearWeights","isAnimating","runAStar","runBFS","runDFS","runDijkstra","runGreedyBFS","runRecursiveDivision","toggleAlgorithmType","toggleButtonState","e","name","target","innerHTML","runAlgorithm","Navbar","bg","expand","Brand","href","style","color","Toggle","aria-controls","Collapse","Nav","NavDropdown","title","Dropdown","disabled","Node","row","col","isStart","isFinish","isWall","isWeight","onMouseDown","onMouseOver","onMouseUp","extraClassName","preventDefault","MinHeapAStar","array","this","heap","buildHeap","n","length","i","Math","floor","siftDown","l","r","minIdx","f","swap","value","pop","push","siftUp","j","c","findOptimalPathAStar","grid","startNode","endNode","visitedNodesInOrder","nodes","node","findAllNodes","Infinity","g","h","findHeuristicDistance","pq","currentNode","remove","neighbours","findNeighbours","w","gScoreSoFar","previous","insert","matrix","m","x","y","abs","MinHeapDijkstra","distance","findRecursiveDivisionMaze","HEIGHT","WIDTH","nodeOne","nodeTwo","recursiveDivisionHelper","rowStart","rowEnd","colStart","colEnd","orientation","potentialRows","num","potentialCols","randomRowIdx","random","randomColIdx","currentRow","randomCol","currentCol","randomRow","START_NODE_ROW","NUM_ROWS","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","findInitialGrid","createNode","isVisited","findNewGridWithNewStart","newGrid","slice","findNewGridWithNewTarget","findNewGridWithWallToggled","newNode","findNewGridWithWeightToggled","PathVisualizer","setGrid","keyCode","setKeyCode","setIsAnimating","isClicked","setIsClicked","isLocked","setIsLocked","isMousePressed","setIsMousePressed","isStartClicked","setIsStartClicked","isTargetClicked","setIsTargetClicked","isWeightedAlgorithm","setIsWeightedAlgorithm","useEffect","document","addEventListener","handleKeyDown","handleKeyUp","currentGrid","getElementById","indexOf","animateShortestPath","nodesInShortestPathOrder","setTimeout","animateMaze","nodesInShortestPathAStar","animateAStar","unshift","findPathAStar","nodesInShortestPathBFS","animateBFS","Q","shift","neighbour","findOptimalPathBFS","path","findPathBFS","animateDFS","stack","currentNeighbours","forEach","findDFS","animateDijkstra","findOptimalPathDijkstra","findPathDijkstra","map","rowIdx","key","nodeIdx","console","log","handleMouseDown","handleMouseOver","handleMouseUp","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.513e836d.chunk.js","sourcesContent":["\r\nimport React from 'react';\r\nimport './Info.css';\r\nimport '../PathVisualizer';\r\nimport ListGroup from 'react-bootstrap/ListGroup';\r\n\r\nconst Info = () => {\r\n    \r\n    return (\r\n        <div className=\"info\">\r\n            <ListGroup horizontal>\r\n                <ListGroup.Item>\r\n                    <div className=\"start\"></div> Start Node\r\n                </ListGroup.Item>\r\n                <ListGroup.Item>\r\n                    <div className=\"target\"></div> Target Node\r\n                </ListGroup.Item>\r\n                <ListGroup.Item>\r\n                    <div className=\"wall\"></div> Wall Node\r\n                </ListGroup.Item>\r\n                <ListGroup.Item>\r\n                    <div className=\"weight\"></div> Weight Node\r\n                </ListGroup.Item>\r\n                <ListGroup.Item>\r\n                    <div className=\"visited\"></div> Visited Node\r\n                </ListGroup.Item>\r\n                <ListGroup.Item>\r\n                    <div className=\"unvisited\"></div> Unvisited Node\r\n                </ListGroup.Item>\r\n                <ListGroup.Item>\r\n                    <div className=\"shortest-path\"></div> Shortest Path Node\r\n                </ListGroup.Item>\r\n            </ListGroup>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Info\r\n","\r\nimport React from 'react';\r\nimport Button from 'react-bootstrap/Button';\r\nimport Modal from 'react-bootstrap/Modal';\r\nimport './Tutorial.css';\r\n\r\nexport const Tutorial = ({ tutorial, showTutorial }) => {\r\n\r\n    return (\r\n        <Modal\r\n            size=\"lg\"\r\n            show={tutorial}\r\n            onHide={() => showTutorial(false)}\r\n            aria-labelledby=\"example-modal-sizes-title-lg\"\r\n        >\r\n            <Modal.Header closeButton>\r\n                <Modal.Title id=\"example-modal-sizes-title-lg\">\r\n                    Welcome to Path Visualizer!    \r\n                </Modal.Title>\r\n            </Modal.Header>\r\n            <Modal.Body>\r\n                <p>This is quick tutorial on how to navigate this application.</p>\r\n                <p> \r\n                    <i>If you wish to skip this tutorial, click on the <i class=\"fas fa-times\"></i> icon above.</i> \r\n                </p>\r\n                <h5>\r\n                    What Are Path Algorithms?</h5>\r\n                <div className=\"info-box\">\r\n                    <p>Path Algorithms are a set of algorithms that allow us to find a \r\n                        path (possibly <strong>shortest</strong>) between two vertices in a graph. \r\n                        This application allows you to interact with and visualize some awesome path \r\n                        algorithms that can help you enhance your understanding of some of the algorithms \r\n                        at hand.</p>\r\n                </div>\r\n                <h5>\r\n                    How To Use This App</h5>\r\n                <div className=\"demo-box\">\r\n                    <p><b>Step 1</b>: Select an Algorithm</p>\r\n                    <p>Click on the Algorithms tab and select an algorithm \r\n                        from the dropdown menu.</p>\r\n                    <p>Note that some algorithms are unweighted while others are weighted. If you select a weighted \r\n                        algorithm, you will be able to add weights onto the grid (see Step 2). </p>\r\n                </div>\r\n                <div className=\"demo-box\">\r\n                    <p><b>Step 2</b>: Adding Walls and Weights</p>\r\n                    <p>All algorithms in this application utilise the interactive grid provided\r\n                    to you. Before adding walls and weights, you can click on the start or target nodes \r\n                    and move them around to a different position on the grid. </p> \r\n                    <p> You can click and drag on the grid to add walls. If you have selected\r\n                        a weighted algorithm, click and drag whilst holding the <div className='key'>W</div> key \r\n                        to add weights.</p>\r\n                    <p>Walls are impenetrable whereas weights are penetrable. Passing through an unweighted node\r\n                        incurs a cost of one unit. Passing through a weighted node however, incurs a cost of 10 units.\r\n                    </p>\r\n                </div>\r\n                <div className=\"demo-box\">\r\n                    <p> <b>Step 3</b>: Visualizing an Algorithm and More </p>\r\n                    <p> This is the fun part. Click on the <i className=\"fas fa-eye\"></i> Visualize Algorithm button \r\n                        to witness your path algorithm in action! </p>\r\n                    <p>\r\n                        Algorithms which  <i> guarantee </i> a shortest path will display such a path once complete\r\n                        (highlighted in yellow). If the shortest path passes through a weight node, this too will be\r\n                        indicated in the path.\r\n                    </p>\r\n                    <p>Once the algorithm completes, you can perform other actions to modify or rerun your algorithm.\r\n                        You will be able to use the navigation bar to clear the current path (if it exists), clear \r\n                        walls and weights, clear the board and select other path algorithms of your choice.</p>\r\n                </div>\r\n                <div className=\"demo-box\">\r\n                    <p> <b>Optional</b>: Generating Mazes </p>\r\n                    <p> Click on the Mazes tab and select a maze generation algorithm to generate a randomized\r\n                        maze. </p>\r\n                    <p>You can then apply any path algorithm of your choice to witness it navigate through a maze. </p>\r\n                </div>\r\n                <div className=\"end-box\">\r\n                    <p> <b>Enjoy!</b>  </p>\r\n                    <p>I hope you enjoy using this application and find it useful. If you wish to \r\n                        revisit this tutorial, you can do so by clicking on the <i className=\"fas fa-book-open\"></i> Tutorial button \r\n                        located on the navigation bar or hitting the <div className='key'>F5</div> key to reload. \r\n                    </p>\r\n                    <p>If you wish to view the source code for this application, please feel free to visit my \r\n                        <Button variant=\"primary\">\r\n                            GitHub\r\n                        </Button></p>\r\n                </div>\r\n            </Modal.Body>\r\n            <Modal.Footer>\r\n                <Button variant=\"secondary\" onClick={() => showTutorial(false)}>\r\n                    Close\r\n                </Button>\r\n            </Modal.Footer>\r\n        </Modal>\r\n    )\r\n}\r\n\r\nexport default Tutorial;\r\n","\r\nimport React, { useState } from 'react';\r\nimport Button from 'react-bootstrap/Button';\r\nimport Dropdown from 'react-bootstrap/Dropdown';\r\nimport Nav from 'react-bootstrap/Nav';\r\nimport Navbar from 'react-bootstrap/Navbar';\r\nimport NavDropdown from 'react-bootstrap/NavDropdown';\r\nimport Tutorial from '../Tutorial/Tutorial';\r\nimport './NavBar.css';\r\nimport '../PathVisualizer';\r\n\r\nconst NavBar = props => {\r\n    \r\n    const [mainButton, setMainButton] = useState(\r\n        <Button id=\"default\" className=\"btn\" variant=\"success\">\r\n            <i className=\"fas fa-arrow-circle-left\"></i> Visualize Algorithm!</Button>\r\n        );\r\n    const [tutorial, setTutorial] = useState(true);\r\n\r\n    const { clearGrid, clearPath, clearWalls, clearWeights, isAnimating,\r\n        runAStar, runBFS, runDFS, runDijkstra, runGreedyBFS, runRecursiveDivision, \r\n        toggleAlgorithmType } = props;\r\n\r\n    const runAlgorithm = e => {\r\n        const id = e.target.id;\r\n        if (id === 'AStar') runAStar();\r\n        if (id === 'BFS') runBFS();\r\n        if (id === 'DFS') runDFS();\r\n        if (id === 'Dijkstra') runDijkstra();\r\n        if (id === 'GreedyBFS') runGreedyBFS();\r\n    }\r\n\r\n    const toggleButtonState = e => {\r\n        const name = e.target.innerHTML;\r\n        setMainButton(\r\n            <Button id={e.target.id} variant=\"success\" onClick={e => {runAlgorithm(e);}}>\r\n                <i className=\"fas fa-eye\"></i> Visualize {name}!</Button>\r\n        )\r\n    }\r\n\r\n    return (\r\n        <Navbar bg=\"dark\" expand=\"lg\">\r\n            <Navbar.Brand href=\"\">\r\n                <h3 style={{color : 'white'}}>\r\n                    <i className=\"far fa-compass\"></i> Path Visualizer\r\n                </h3>\r\n            </Navbar.Brand>\r\n            <Navbar.Toggle aria-controls=\"basic-navbar-nav\" />\r\n            <Navbar.Collapse id=\"responsive-navbar-nav\">\r\n                <Nav className=\"mr-auto\">\r\n                    <NavDropdown title=\"Algorithms\" id=\"basic-nav-dropdown\">\r\n                        <Dropdown.Item id=\"AStar\" disabled={isAnimating()} onClick={e => {\r\n                            toggleButtonState(e); \r\n                            toggleAlgorithmType(e);\r\n                            clearPath();\r\n                        }}>\r\n                            A* Search\r\n                        </Dropdown.Item>\r\n                        <Dropdown.Item id=\"BFS\" disabled={isAnimating()} onClick={e => {\r\n                            toggleButtonState(e);\r\n                            toggleAlgorithmType(e);\r\n                            clearWeights();\r\n                            clearPath();\r\n\r\n                        }}>\r\n                            Breadth-First Search\r\n                        </Dropdown.Item>\r\n                        <Dropdown.Item id=\"DFS\" disabled={isAnimating()} onClick={e => {\r\n                            toggleButtonState(e);\r\n                            toggleAlgorithmType(e);\r\n                            clearWeights();\r\n                            clearPath();\r\n                        }}>\r\n                            Depth-First Search\r\n                        </Dropdown.Item>\r\n                        <Dropdown.Item id=\"Dijkstra\" disabled={isAnimating()} onClick={e => {\r\n                            toggleButtonState(e);\r\n                            toggleAlgorithmType(e);\r\n                            clearPath()\r\n                        }}>\r\n                            Dijkstra's Algorithm\r\n                        </Dropdown.Item>\r\n                        <Dropdown.Item id=\"GreedyBFS\" disabled={1} onClick={e => {\r\n                            toggleButtonState(e);\r\n                            toggleAlgorithmType(e);\r\n                            clearPath()\r\n                        }}>\r\n                            Greedy Best-First Search (TBA)\r\n                        </Dropdown.Item>\r\n                    </NavDropdown>\r\n                    <NavDropdown title=\"Mazes\" id=\"basic-nav-dropdown\">\r\n                        <Dropdown.Item id=\"Recursive\" disabled={isAnimating()} onClick={() => {\r\n                            clearGrid();\r\n                            runRecursiveDivision();\r\n                        }}>\r\n                            Recursive Division\r\n                        </Dropdown.Item>\r\n                    </NavDropdown>\r\n                    {isAnimating() \r\n                        ? \r\n                        <Button disabled={true} variant=\"success\">\r\n                            <i className=\"fas fa-spinner\"></i> Visualizing Algorithm...\r\n                        </Button> \r\n                        : mainButton\r\n                    }\r\n                    <Button disabled={isAnimating()} onClick={() => clearWalls()} variant=\"primary\">Clear Walls</Button>\r\n                    <Button disabled={isAnimating()} onClick={() => clearWeights()} variant=\"primary\">Clear Weights</Button>\r\n                    <Button disabled={isAnimating()} onClick={() => clearPath()} variant=\"primary\">Clear Path</Button>\r\n                    <Button disabled={isAnimating()} onClick={() => clearGrid()} variant=\"danger\">\r\n                        <i className=\"fas fa-redo-alt\"></i> Reset Grid\r\n                    </Button>\r\n                    <Button disabled={isAnimating()} onClick={() => setTutorial(true)} variant=\"info\">\r\n                        <i className=\"fas fa-book-open\"></i> Tutorial\r\n                    </Button>\r\n                    <Tutorial\r\n                        tutorial = {tutorial}\r\n                        showTutorial={setTutorial} \r\n                    />\r\n                </Nav>\r\n            </Navbar.Collapse>\r\n        </Navbar>\r\n    )\r\n}\r\n\r\nexport default NavBar;\r\n","\r\nimport React from 'react';\r\nimport './Node.css';\r\n\r\nconst Node = props => {\r\n\r\n    const {row, col, isStart, isFinish, isWall, isWeight, onMouseDown, onMouseOver, onMouseUp} = props;\r\n    const extraClassName = isStart ? 'node-start' : isFinish ? 'node-finish' : isWall ? 'node-wall' : \r\n                        isWeight ? 'node-weight' : '';\r\n    return (\r\n        <td \r\n            id={`node-${row}-${col}`}\r\n            className={`node ${extraClassName}`}\r\n            onMouseDown={e => {e.preventDefault(); onMouseDown(row, col)}}\r\n            onMouseOver={() => onMouseOver(row, col)}\r\n            onMouseUp={() => onMouseUp(row, col)}>\r\n        </td>\r\n    );\r\n}\r\n\r\nexport default Node;\r\n","\r\nclass MinHeapAStar {\r\n    constructor(array) {\r\n        this.heap = this.buildHeap(array);\r\n    }\r\n\r\n    buildHeap(array) {\r\n        const n = array.length;\r\n        for (let i = Math.floor(n / 2); i >= 0; i--) {\r\n            this.siftDown(i, n, array);\r\n        }\r\n        return array;\r\n    }\r\n\r\n    siftDown(i, n, heap) {\r\n        let l = 2 * i + 1;\r\n        while (l < n) {\r\n            let r = 2 * i + 2 < n ? 2 * i + 2 : -1;\r\n            let minIdx = (r !== -1 && heap[r].f < heap[l].f) ? r : l;\r\n            if (heap[minIdx].f < heap[i].f) {\r\n                this.swap(minIdx, i, heap);\r\n                i = minIdx;\r\n                l = 2 * i + 1;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    siftUp(i, heap) {\r\n        while (i > 0 && heap[i].f < heap[Math.floor((i - 1) / 2)].f) {\r\n            this.swap(i, Math.floor((i - 1) / 2), heap);\r\n            i = Math.floor((i - 1) / 2);\r\n        }\r\n    }\r\n\r\n    peek() {\r\n        return this.heap[0].f;\r\n    }\r\n\r\n    remove() {\r\n        this.swap(0, this.heap.length - 1, this.heap);\r\n        const value = this.heap.pop();\r\n        this.siftDown(0, this.heap.length, this.heap);\r\n        return value;\r\n    }\r\n\r\n    insert(value) {\r\n        this.heap.push(value);\r\n        this.siftUp(this.heap.length - 1, this.heap);\r\n    }\r\n\r\n    swap(i, j, heap) {\r\n        const c = heap[i];\r\n        heap[i] = heap[j];\r\n        heap[j] = c;\r\n    }\r\n}\r\n\r\nexport default MinHeapAStar;\r\n","\r\nimport MinHeapAStar from \"./HeapAStar\";\r\n\r\nexport function findOptimalPathAStar(grid, startNode, endNode) {\r\n    const visitedNodesInOrder = [startNode];\r\n    const nodes = findAllNodes(grid);\r\n    for (let node of nodes) {\r\n        node.f = Infinity; \r\n        node.g = Infinity;\r\n        node.h = Infinity;\r\n    }\r\n    startNode.h = findHeuristicDistance(startNode, endNode);\r\n    startNode.g = 0;\r\n    startNode.f = startNode.h;\r\n    const pq = new MinHeapAStar([startNode]);\r\n\r\n    while (pq.heap.length) {\r\n        const currentNode = pq.remove();\r\n        const neighbours = findNeighbours(currentNode, grid);\r\n        for (let node of neighbours) {\r\n            if (node.isWall) continue;\r\n            const w = node.isWeight ? 10 : 1;\r\n            const gScoreSoFar = currentNode.g + w;\r\n            if (gScoreSoFar < node.g) {\r\n                node.previous = currentNode;\r\n                node.h = findHeuristicDistance(node, endNode);\r\n                node.g = gScoreSoFar;\r\n                node.f = node.g + node.h;\r\n                visitedNodesInOrder.push(node);\r\n                if (node === endNode) return visitedNodesInOrder;\r\n                pq.insert(node);\r\n            }\r\n        }\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction findAllNodes(grid) {\r\n    const nodes = [];\r\n    for (let row of grid) {\r\n        for (let node of row) {\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\nfunction findNeighbours(node, matrix) {\r\n    const neighbours = [];\r\n    const m = matrix.length;\r\n    const n = matrix[0].length;\r\n    const { row, col } = node;\r\n    const DIR = [[-1, 0], [0, 1], [0, -1], [1, 0]];\r\n    for (let [di, dj] of DIR) {\r\n        let x = row + di;\r\n        let y = col + dj;\r\n        if (x >= 0 && x < m && y >= 0 && y < n) {\r\n            neighbours.push(matrix[x][y]);\r\n        }\r\n    }\r\n    return neighbours\r\n}\r\n\r\nfunction findHeuristicDistance(x, y) {\r\n    return Math.abs(x.row - y.row) + Math.abs(x.col - y.col);\r\n}\r\n\r\nexport function findPathAStar(endNode) {\r\n    const nodes = [];\r\n    let currentNode = endNode;\r\n    while (currentNode !== null) {\r\n        nodes.unshift(currentNode);\r\n        currentNode = currentNode.previous;\r\n    }\r\n    return nodes;\r\n}\r\n","\r\nexport function findOptimalPathBFS(grid, startNode, endNode) {\r\n    const nodes = [startNode];\r\n    const Q = [startNode];\r\n    while (Q.length) {\r\n        const currentNode = Q.shift();\r\n        const neighbours = findNeighbours(currentNode, grid);\r\n        for (let neighbour of neighbours) {\r\n            if (neighbour.isWall || neighbour.isVisited) continue;\r\n            neighbour.isVisited = true;\r\n            neighbour.previous = currentNode;\r\n            nodes.push(neighbour);\r\n            if (neighbour === endNode) return nodes;\r\n            Q.push(neighbour);\r\n        }\r\n        startNode.previous = null;\r\n    }\r\n    return nodes;\r\n}\r\n\r\nfunction findNeighbours(node, matrix) {\r\n    const neighbours = [];\r\n    const m = matrix.length;\r\n    const n = matrix[0].length;\r\n    const {row, col} = node;\r\n    const DIR = [[-1, 0], [0, 1], [0, -1], [1, 0]];\r\n    for (let [di, dj] of DIR) {\r\n        let x = row + di;\r\n        let y = col + dj;\r\n        if (x >= 0 && x < m && y >= 0 && y < n) {\r\n            neighbours.push(matrix[x][y]);\r\n        }\r\n    }\r\n    return neighbours;\r\n}\r\n\r\nexport function findPathBFS(endNode) {\r\n    const path = [];\r\n    let currentNode = endNode;\r\n    while (currentNode !== null) {\r\n        path.unshift(currentNode);\r\n        currentNode = currentNode.previous;\r\n    }\r\n    return path;\r\n}\r\n","\r\nexport function findDFS(grid, startNode, endNode) {\r\n    const nodes = [];\r\n    const stack = [startNode];\r\n    while (stack.length) {\r\n        const currentNode = stack.pop();\r\n        const currentNeighbours = findNeighbours(currentNode, grid);\r\n        if (!currentNode.isVisited) {\r\n            currentNode.isVisited = true;\r\n            nodes.push(currentNode);\r\n            if (currentNode === endNode) {\r\n                return nodes;\r\n            }\r\n            currentNeighbours.forEach(neighbour => {\r\n                stack.push(neighbour);\r\n            });\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\nfunction findNeighbours(node, matrix) {\r\n    const neighbours = [];\r\n    const m = matrix.length;\r\n    const n = matrix[0].length;\r\n    const { row, col } = node;\r\n    const DIR = [[0, -1], [-1, 0], [0, 1], [1, 0]];\r\n    for (let [di, dj] of DIR) {\r\n        let x = row + di;\r\n        let y = col + dj;\r\n        if (x >= 0 && x < m && y >= 0 && y < n) {\r\n            neighbours.push(matrix[x][y]);\r\n        }\r\n    }\r\n    return neighbours;\r\n}\r\n","\r\nclass MinHeapDijkstra {\r\n    constructor(array) {\r\n        this.heap = this.buildHeap(array);\r\n    }\r\n\r\n    buildHeap(array) {\r\n        const n = array.length;\r\n        for (let i = Math.floor(n / 2); i >= 0; i--) {\r\n            this.siftDown(i, n, array);\r\n        }\r\n        return array;\r\n    }\r\n\r\n    siftDown(i, n, heap) {\r\n        let l = 2 * i + 1;\r\n        while (l < n) {\r\n            let r = 2 * i + 2 < n ? 2 * i + 2 : -1;\r\n            let minIdx = (r !== -1 && heap[r].distance < heap[l].distance) ? r : l;\r\n            if (heap[minIdx].distance < heap[i].distance) {\r\n                this.swap(minIdx, i, heap);\r\n                i = minIdx;\r\n                l = 2 * i + 1;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    siftUp(i, heap) {\r\n        while (i > 0 && heap[i].distance < heap[Math.floor((i - 1) / 2)].distance) {\r\n            this.swap(i, Math.floor((i - 1) / 2), heap);\r\n            i = Math.floor((i - 1) / 2);\r\n        }\r\n    }\r\n\r\n    remove() {\r\n        this.swap(0, this.heap.length - 1, this.heap);\r\n        const value = this.heap.pop();\r\n        this.siftDown(0, this.heap.length, this.heap);\r\n        return value;\r\n    }\r\n\r\n    insert(value) {\r\n        this.heap.push(value);\r\n        this.siftUp(this.heap.length - 1, this.heap);\r\n    }\r\n\r\n    swap(i, j, heap) {\r\n        const c = heap[i];\r\n        heap[i] = heap[j];\r\n        heap[j] = c;\r\n    }\r\n}\r\n\r\nexport default MinHeapDijkstra;\r\n","\r\nimport MinHeapDijkstra from \"./HeapDijkstra\"\r\n\r\nexport function findOptimalPathDijkstra(grid, startNode, endNode) {\r\n    const visitedNodesInOrder = [startNode];\r\n    startNode.distance = 0;\r\n    const pq = new MinHeapDijkstra([startNode]);\r\n    while (pq.heap.length) {\r\n        const currentNode = pq.remove();\r\n        const neighbours = findNeighbours(currentNode, grid);\r\n        for (let node of neighbours) {\r\n            if (node.isWall || node.isVisited) continue;\r\n            let w = node.isWeight ? 4 : 1;\r\n            if (currentNode.distance + w < node.distance) {\r\n                node.distance = currentNode.distance + w;\r\n                node.previous = currentNode;\r\n                node.isVisited = true;\r\n                visitedNodesInOrder.push(node);\r\n                if (node === endNode) return visitedNodesInOrder;\r\n                pq.insert(node);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction findNeighbours(node, matrix) {\r\n    const neighbours = [];\r\n    const m = matrix.length;\r\n    const n = matrix[0].length;\r\n    const { row, col } = node;\r\n    const DIR = [[-1, 0], [0, 1], [0, -1], [1, 0]];\r\n    for (let [di, dj] of DIR) {\r\n        let x = row + di;\r\n        let y = col + dj;\r\n        if (x >= 0 && x < m && y >= 0 && y < n) {\r\n            neighbours.push(matrix[x][y]);\r\n        }\r\n    }\r\n    return neighbours\r\n}\r\n\r\nexport function findPathDijkstra(endNode) {\r\n    const path = [];\r\n    let currentNode = endNode;\r\n    while (currentNode !== null) {\r\n        path.unshift(currentNode);\r\n        currentNode = currentNode.previous;\r\n    }\r\n    return path;\r\n}\r\n","\r\nexport function findRecursiveDivisionMaze(grid) {\r\n    const visitedNodesInOrder = [];\r\n    const HEIGHT = grid.length;\r\n    const WIDTH = grid[0].length;\r\n\r\n    for (let col = 0; col < WIDTH; col++) {\r\n        const node = grid[0][col];\r\n        visitedNodesInOrder.push(node);\r\n    }\r\n\r\n    for (let row = 0; row < HEIGHT; row++) {\r\n        const nodeOne = grid[row][0];\r\n        const nodeTwo = grid[row][WIDTH - 1];\r\n        visitedNodesInOrder.push(nodeOne, nodeTwo);\r\n    }\r\n\r\n    for (let col = 0; col < WIDTH; col++) {\r\n        const node = grid[HEIGHT - 1][col];\r\n        visitedNodesInOrder.push(node);\r\n    }\r\n\r\n    recursiveDivisionHelper(grid, visitedNodesInOrder, 2, HEIGHT - 3, 2, WIDTH - 3, 'horizontal');\r\n\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction recursiveDivisionHelper(grid, visitedNodesInOrder, rowStart, rowEnd, colStart, colEnd, orientation) {\r\n\r\n    if (rowStart > rowEnd || colStart > colEnd) return;\r\n\r\n    if (orientation === 'horizontal') {\r\n        let potentialRows = [];\r\n        for (let num = rowStart; num <= rowEnd; num += 2) {\r\n            potentialRows.push(num);\r\n        }\r\n        let potentialCols = [];\r\n        for (let num = colStart - 1; num <= colEnd; num += 2) {\r\n            potentialCols.push(num);\r\n        }\r\n        let randomRowIdx = Math.floor(Math.random() * potentialRows.length);\r\n        let randomColIdx = Math.floor(Math.random() * potentialCols.length);\r\n        let currentRow = potentialRows[randomRowIdx];\r\n        let randomCol = potentialCols[randomColIdx];\r\n        for (let col = colStart - 1; col <= colEnd + 1; col++) {\r\n            if (col === randomCol) continue;\r\n            const node = grid[currentRow][col];\r\n            if (node.isStart || node.isFinish) continue; \r\n            visitedNodesInOrder.push(node);\r\n        }\r\n        if (currentRow - 2 - rowStart > colEnd - colStart) {\r\n            recursiveDivisionHelper(grid, visitedNodesInOrder, rowStart, currentRow - 2, colStart, colEnd, orientation);\r\n        } else {\r\n            recursiveDivisionHelper(grid, visitedNodesInOrder, rowStart, currentRow - 2, colStart, colEnd, \"vertical\");\r\n        } \r\n        if (rowEnd - (currentRow + 2) > colEnd - colStart) {\r\n            recursiveDivisionHelper(grid, visitedNodesInOrder, currentRow + 2, rowEnd, colStart, colEnd, orientation);\r\n        } else {\r\n            recursiveDivisionHelper(grid, visitedNodesInOrder, currentRow + 2, rowEnd, colStart, colEnd, \"vertical\");\r\n        }\r\n\r\n    } else {\r\n        let potentialCols = [];\r\n        for (let num = colStart; num <= colEnd; num += 2) {\r\n            potentialCols.push(num);\r\n        }\r\n        let potentialRows = [];\r\n        for (let num = rowStart - 1; num <= rowStart + 1; num += 2) {\r\n            potentialRows.push(num);\r\n        }\r\n        let randomColIdx = Math.floor(Math.random() * potentialCols.length);\r\n        let randomRowIdx = Math.floor(Math.random() * potentialRows.length);\r\n        let currentCol = potentialCols[randomColIdx];\r\n        let randomRow = potentialRows[randomRowIdx];\r\n        for (let row = rowStart - 1; row <= rowEnd + 1; row++) {\r\n            if (row === randomRow) continue;\r\n            const node = grid[row][currentCol];\r\n            if (node.isStart || node.isFinish) continue; \r\n            visitedNodesInOrder.push(node);\r\n        }\r\n        if (rowEnd - rowStart > currentCol - 2 - colStart) {\r\n            recursiveDivisionHelper(grid, visitedNodesInOrder, rowStart, rowEnd, colStart, currentCol - 2, \"horizontal\");\r\n        } else {\r\n            recursiveDivisionHelper(grid, visitedNodesInOrder, rowStart, rowEnd, colStart, currentCol - 2, orientation);\r\n        }\r\n        if (rowEnd - rowStart > colEnd - (currentCol + 2)) {\r\n            recursiveDivisionHelper(grid, visitedNodesInOrder, rowStart, rowEnd, currentCol + 2, colEnd, \"horizontal\");\r\n        } else {\r\n            recursiveDivisionHelper(grid, visitedNodesInOrder, rowStart, rowEnd, currentCol + 2, colEnd, orientation);\r\n        }\r\n    }\r\n}\r\n","\r\nimport React, { useState, useEffect } from 'react';\r\nimport './PathVisualizer.css';\r\nimport Info from './Info/Info';\r\nimport NavBar from './NavBar/NavBar';\r\nimport Node from './Node/Node';\r\nimport { findOptimalPathAStar, findPathAStar } from '../Algorithms/AStar';\r\nimport { findOptimalPathBFS, findPathBFS } from '../Algorithms/BreadthFirstSearch';\r\nimport { findDFS } from '../Algorithms/DepthFirstSearch';\r\nimport { findOptimalPathDijkstra, findPathDijkstra } from '../Algorithms/Djikstra';\r\nimport { findRecursiveDivisionMaze } from '../Mazes/RecursiveDivision';\r\n\r\nlet NUM_ROWS = 15;\r\nlet NUM_COLS = 40;\r\n\r\nlet START_NODE_ROW = Math.floor(NUM_ROWS / 2);\r\nlet START_NODE_COL = 4;\r\nlet FINISH_NODE_ROW = Math.floor(NUM_ROWS / 2);\r\nlet FINISH_NODE_COL = NUM_COLS - START_NODE_COL - 1;\r\n\r\nconst PathVisualizer = () => {\r\n    \r\n    const [grid, setGrid] = useState([]);\r\n    const [keyCode, setKeyCode] = useState(false);\r\n    const [isAnimating, setIsAnimating] = useState(false);\r\n    const [isClicked, setIsClicked] = useState(false);\r\n    const [isLocked, setIsLocked] = useState(false);\r\n    const [isMousePressed, setIsMousePressed] = useState(false);\r\n    const [isStartClicked, setIsStartClicked] = useState(false);\r\n    const [isTargetClicked, setIsTargetClicked] = useState(false);\r\n    const [isWeightedAlgorithm, setIsWeightedAlgorithm] = useState(false);\r\n\r\n    useEffect(() => {\r\n        const grid = findInitialGrid();\r\n        document.addEventListener('keydown', e => handleKeyDown(e));\r\n        document.addEventListener('keyup', () => handleKeyUp());\r\n        setGrid(grid);\r\n    }, []);\r\n\r\n    const handleMouseDown = (row, col) => {\r\n        if (!isLocked && row === START_NODE_ROW && col === START_NODE_COL) {\r\n            setIsStartClicked(true);\r\n            console.log('Start Node...');\r\n        }\r\n        else if (!isLocked && row === FINISH_NODE_ROW && col === FINISH_NODE_COL) {\r\n            setIsTargetClicked(true);\r\n            console.log('Target Node...');\r\n        }\r\n        else if (!isAnimating) {\r\n            if (keyCode !== 87) {\r\n                const newGrid = findNewGridWithWallToggled(grid, row, col);\r\n                setGrid(newGrid);\r\n                setIsMousePressed(true);       \r\n            } else if (keyCode === 87 && isWeightedAlgorithm) {\r\n                const newGrid = findNewGridWithWeightToggled(grid, row, col);\r\n                setGrid(newGrid);\r\n                setIsMousePressed(true);\r\n            }\r\n        }\r\n    }\r\n\r\n    function handleMouseOver(row, col) {\r\n        if (isStartClicked && !isLocked && !(row === FINISH_NODE_ROW && col === FINISH_NODE_COL)) {\r\n            const newGrid = findNewGridWithNewStart(grid, row, col);\r\n            setGrid(newGrid);\r\n            console.log('Moving...');\r\n        }\r\n        else if (isTargetClicked && !isLocked && !(row === START_NODE_ROW && col === START_NODE_COL)) {\r\n            const newGrid = findNewGridWithNewTarget(grid, row, col);\r\n            setGrid(newGrid);\r\n        } else {\r\n            if (!isMousePressed) return null;\r\n            if (keyCode !== 87) {\r\n                const newGrid = findNewGridWithWallToggled(grid, row, col);\r\n                setGrid(newGrid);\r\n                setIsMousePressed(true);\r\n                console.log('Moving...');\r\n            } else if (keyCode === 87 && isWeightedAlgorithm) {\r\n                const newGrid = findNewGridWithWeightToggled(grid, row, col);\r\n                setGrid(newGrid);\r\n                setIsMousePressed(true);\r\n            }\r\n        }\r\n        \r\n    }\r\n\r\n    const handleMouseUp = (row, col) => {\r\n        if (isStartClicked) {\r\n            const newGrid = findNewGridWithNewStart(grid, row, col);\r\n            setGrid(newGrid);\r\n            setIsStartClicked(false)\r\n        } else if (isTargetClicked) {\r\n            const newGrid = findNewGridWithNewTarget(grid, row, col);\r\n            setGrid(newGrid);\r\n            setIsTargetClicked(false);\r\n        }\r\n        setIsMousePressed(false);\r\n    }\r\n\r\n    const handleKeyDown = e => {\r\n        setKeyCode(e.keyCode);\r\n    }\r\n\r\n    const handleKeyUp = () => {\r\n        setKeyCode(false)\r\n    }\r\n\r\n    const toggleAlgorithmType = e => {\r\n        const id = e.target.id;\r\n        if (id === 'AStar' || id === 'Dijkstra' || id === 'GreedyBFS') {\r\n            setIsWeightedAlgorithm(true);\r\n        } else {\r\n            setIsWeightedAlgorithm(false);\r\n        }\r\n    }\r\n\r\n    const isAnimatingNow = () => {\r\n        return isAnimating;\r\n    }\r\n\r\n    const clearGrid = () => {\r\n        const currentGrid = grid.slice();\r\n        for (let row of currentGrid) {\r\n            for (let node of row) {\r\n                node.distance = Infinity;\r\n                node.isVisited = false;\r\n                node.isWall = false;\r\n                node.isWeight = false;\r\n                node.previous = null;\r\n                const currentNode = document.getElementById(`node-${node.row}-${node.col}`);\r\n                currentNode.className = 'node';\r\n            }\r\n        }\r\n        const startNode = document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`);\r\n        startNode.className = 'node node-start';\r\n        const endNode = document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`);\r\n        endNode.className = 'node node-finish';\r\n        setGrid(currentGrid);\r\n        setIsMousePressed(false);\r\n        setIsAnimating(false);\r\n        setIsClicked(false);\r\n        setIsLocked(false);\r\n    }\r\n\r\n    const clearPath = () => {\r\n        const currentGrid = grid.slice();\r\n        for (let row of currentGrid) {\r\n            for (let node of row) {\r\n                node.distance = Infinity;\r\n                node.isVisited = false;\r\n                node.previous = null;\r\n                const currentNode = document.getElementById(`node-${node.row}-${node.col}`);\r\n                if (currentNode.className === 'node shortest-path-weight' || node.isWeight) {\r\n                    currentNode.className = 'node node-weight';\r\n                } else if (['node node-visited', 'node node-shortest-path'].indexOf(currentNode.className) !== -1) {\r\n                    currentNode.className = 'node';\r\n                }\r\n            }\r\n        }\r\n        const startNode = document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`);\r\n        startNode.className = 'node node-start';\r\n        const endNode = document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`);\r\n        endNode.className = 'node node-finish';\r\n        setGrid(currentGrid);\r\n        setIsMousePressed(false);\r\n        setIsAnimating(false);\r\n        setIsClicked(false);\r\n        setIsLocked(false);\r\n    }\r\n\r\n    const clearWalls = () => {\r\n        const currentGrid = grid.slice();\r\n        for (let row of currentGrid) {\r\n            for (let node of row) {\r\n                if (node.isWall) {\r\n                    node.isWall = !node.isWall;\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\r\n                }\r\n            }\r\n        }\r\n        setGrid(currentGrid);\r\n        setIsMousePressed(false);\r\n    }\r\n\r\n    const clearWeights = () => {\r\n        const currentGrid = grid.slice();\r\n        for (let row of currentGrid) {\r\n            for (let node of row) {\r\n                if (node.isWeight) {\r\n                    node.isWeight = !node.isWeight;\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\r\n                }\r\n            }\r\n        }\r\n        setGrid(currentGrid)\r\n        setIsMousePressed(false);\r\n    }\r\n\r\n    function animateAStar(visitedNodesInOrder, nodesInShortestPathAStar) {\r\n        for (let i = 0; i < visitedNodesInOrder.length; i++) {\r\n            if (i === visitedNodesInOrder.length - 1) {\r\n                setTimeout(() => {\r\n                    animateShortestPath(nodesInShortestPathAStar);\r\n                }, 20*i);\r\n            }\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).className =\r\n                    'node node-visited';\r\n            }, 20*i);\r\n        }\r\n    }\r\n\r\n    function animateBFS(visitedNodesInOrder, nodesInShortestPathBFS) {\r\n        for (let i = 0; i < visitedNodesInOrder.length; i++) {\r\n            if (i === visitedNodesInOrder.length - 1) {\r\n                setTimeout(() => {\r\n                    animateShortestPath(nodesInShortestPathBFS);\r\n                }, 20*i);\r\n            }\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).className =\r\n                    'node node-visited';\r\n            }, 20*i);\r\n        }\r\n    }\r\n\r\n    function animateDFS(visitedNodesInOrder) {\r\n        for (let i = 0; i < visitedNodesInOrder.length; i++) {\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).className =\r\n                    'node node-visited';\r\n            }, 20*i);\r\n        }\r\n        setTimeout(() => {\r\n            setIsAnimating(false);\r\n        }, 3200);\r\n    }\r\n\r\n    function animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n        for (let i = 0; i < visitedNodesInOrder.length; i++) {\r\n            if (i === visitedNodesInOrder.length - 1) {\r\n                setTimeout(() => {\r\n                    animateShortestPath(nodesInShortestPathOrder);\r\n                }, 20*i);\r\n\r\n                return;\r\n            }\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\r\n            }, 20*i);\r\n        }\r\n    }\r\n\r\n    function animateShortestPath(nodesInShortestPathOrder) {\r\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n            setTimeout(() => {\r\n                const node = nodesInShortestPathOrder[i];\r\n                const currentNode = document.getElementById(`node-${node.row}-${node.col}`);\r\n                if (node.isWeight) {\r\n                    currentNode.className = 'node shortest-path-weight';\r\n                } else {\r\n                    currentNode.className = 'node node-shortest-path';\r\n                }\r\n            }, 40*i);\r\n        }\r\n        setTimeout(() => {\r\n            setIsAnimating(false);\r\n            setIsLocked(true);\r\n        }, 1600);\r\n    }\r\n\r\n    const runAStar = () => {\r\n        if (isClicked) clearPath();\r\n        setIsAnimating(true);\r\n        setIsClicked(true);\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const endNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        const visitedNodesInOrder = findOptimalPathAStar(grid, startNode, endNode);\r\n        const nodesInShortestPathAStar = findPathAStar(endNode);\r\n        animateAStar(visitedNodesInOrder, nodesInShortestPathAStar);\r\n    }\r\n\r\n    const runBFS = () => {\r\n        if (isClicked) clearPath();\r\n        setIsAnimating(true);\r\n        setIsClicked(true);\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const endNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        const visitedNodesInOrder = findOptimalPathBFS(grid, startNode, endNode);\r\n        const nodesInShortestPathBFS = findPathBFS(endNode);\r\n        animateBFS(visitedNodesInOrder, nodesInShortestPathBFS);\r\n    }\r\n\r\n    const runDFS = () => {\r\n        if (isClicked) clearPath();\r\n        setIsAnimating(true);\r\n        setIsClicked(true);\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const endNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        const visitedNodesInOrder = findDFS(grid, startNode, endNode);\r\n        animateDFS(visitedNodesInOrder);\r\n    }\r\n\r\n    const runDijkstra = () => {\r\n        if (isClicked) clearPath();\r\n        setIsAnimating(true);\r\n        setIsClicked(true);\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const endNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        const visitedNodesInOrder = findOptimalPathDijkstra(grid, startNode, endNode);\r\n        const nodesInShortestPathOrder = findPathDijkstra(endNode);\r\n        animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    }\r\n\r\n    const runGreedyBFS = () => {\r\n\r\n    }\r\n\r\n    const runRecursiveDivision = () => {\r\n        setIsAnimating(true);\r\n        const visitedNodesInOrder = findRecursiveDivisionMaze(grid);\r\n        animateMaze(visitedNodesInOrder);\r\n    }\r\n\r\n    const animateMaze = visitedNodesInOrder => {\r\n        for (let i = 0; i < visitedNodesInOrder.length; i++) {\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                node.isWall = true;\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-wall';\r\n            }, 12 * i);\r\n        }\r\n        setTimeout(() => {\r\n            setIsAnimating(false);\r\n        }, 8*visitedNodesInOrder.length);\r\n    }\r\n\r\n    return (\r\n        <>\r\n            <NavBar\r\n                runAStar={runAStar}\r\n                runBFS={runBFS}\r\n                runDFS={runDFS}\r\n                runDijkstra={runDijkstra}\r\n                runGreedyBFS={runGreedyBFS}\r\n                runRecursiveDivision={runRecursiveDivision}\r\n                clearGrid={clearGrid}\r\n                clearPath={clearPath}\r\n                clearWalls={clearWalls}\r\n                clearWeights={clearWeights}\r\n                isAnimating={isAnimatingNow}\r\n                toggleAlgorithmType={e => toggleAlgorithmType(e)}></NavBar>\r\n            <Info></Info>\r\n            <table className=\"grid\">\r\n                <tbody>\r\n                    {\r\n                        grid.map((row, rowIdx) => {\r\n                            return (\r\n                                <tr key={rowIdx}>\r\n                                    {\r\n                                        row.map((node, nodeIdx) => {\r\n                                            const { row, col, isStart, isFinish, isWall, isWeight } = node;\r\n                                            return (\r\n                                                <Node\r\n                                                    key={nodeIdx}\r\n                                                    row={row}\r\n                                                    col={col}\r\n                                                    isStart={isStart}\r\n                                                    isFinish={isFinish}\r\n                                                    isWall={isWall}\r\n                                                    isWeight={isWeight}\r\n                                                    isMousePressed={isMousePressed}\r\n                                                    onMouseDown={(row, col) => handleMouseDown(row, col)}\r\n                                                    onMouseOver={(row, col) => handleMouseOver(row, col)}\r\n                                                    onMouseUp={() => handleMouseUp(row, col)}/>\r\n                                            );\r\n                                        })\r\n                                    }\r\n                                </tr>\r\n                            );\r\n                        })\r\n                    }\r\n                </tbody>\r\n            </table>\r\n        </>\r\n    );\r\n}\r\n\r\nconst findInitialGrid = () => {\r\n    const grid = [];\r\n    for (let row = 0; row < NUM_ROWS; row++) {\r\n        const currentRow = [];\r\n        for (let col = 0; col < NUM_COLS; col++) {\r\n            currentRow.push(createNode(row, col));\r\n        }\r\n        grid.push(currentRow);\r\n    }\r\n    return grid;\r\n}\r\n\r\nconst createNode = (row, col) => {\r\n    return {\r\n        row,\r\n        col, \r\n        isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n        isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n        distance: Infinity,\r\n        isVisited: false,\r\n        isWall: false,\r\n        isWeight: false,\r\n        previous: null\r\n    };\r\n}\r\n\r\nconst findNewGridWithNewStart = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    for (let currentRow of newGrid) {\r\n        for (let node of currentRow) {\r\n            node.isStart = false;\r\n            if (node === newGrid[row][col]) {\r\n                node.isStart = true;\r\n                START_NODE_ROW = row;\r\n                START_NODE_COL = col;\r\n            }\r\n        }\r\n    }\r\n    return newGrid\r\n}\r\n\r\nconst findNewGridWithNewTarget = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    for (let currentRow of newGrid) {\r\n        for (let node of currentRow) {\r\n            node.isFinish = false;\r\n            if (node === newGrid[row][col]) {\r\n                node.isFinish = true;\r\n                FINISH_NODE_ROW = row;\r\n                FINISH_NODE_COL = col;\r\n            }\r\n        }\r\n    }\r\n    return newGrid;\r\n}\r\n\r\nconst findNewGridWithWallToggled = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        isWall: !node.isWall,\r\n        isWeight: false\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n}\r\n\r\nconst findNewGridWithWeightToggled = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        isWall: false,\r\n        isWeight: !node.isWeight,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n}\r\n\r\nexport default PathVisualizer\r\n","import React from 'react';\nimport './App.css';\nimport PathVisualizer from './PathVisualizer/PathVisualizer';\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nfunction App() {\n    return (\n        <div className=\"App\">\n            <PathVisualizer />\n        </div>\n    );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}